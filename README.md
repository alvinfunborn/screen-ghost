# Tauri + React + Typescript

This template should help get you started developing with Tauri, React and Typescript in Vite.

## Recommended IDE Setup

- [VS Code](https://code.visualstudio.com/) + [Tauri](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode) + [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)

本项目是为了在windows系统上实现实时截屏,人脸检测位置,并打马赛克的功能.

应用启动时打开主窗口,由用户选择截屏区域或屏幕
选择好屏幕后应用在该屏幕创建一个overlay窗口, 置顶, 透明, 事件穿透
应用开始每50ms截屏一次, 截屏图片提交给人脸检测进程检测人脸位置
应用获取到位置后, 在overlay窗口上对应位置打马赛克;
循环

注意: 
应用在截屏前应当取消马赛克, 截屏完成后恢复马赛克
技术方案应当选择性能最高的, 因为要实现30fps的低延迟视频人脸遮挡效果

## 深入技术方案思考

### 1. 整体架构分析

首先，我需要理解这个项目的核心需求：
- 实时截屏（50ms间隔，相当于20fps）
- 人脸检测
- 实时马赛克覆盖
- 低延迟（目标30fps）

这个需求很有意思，让我从几个维度来分析...

### 2. 技术栈优势分析

**Tauri + Rust + React的优势：**
- Rust提供高性能的系统级操作
- Tauri提供跨平台能力，但主要针对Windows
- React提供灵活的UI交互

**Windows API的必要性：**
- 截屏操作需要直接调用Windows API
- Overlay窗口需要特殊的窗口属性
- 事件穿透需要底层窗口管理

### 3. 核心技术挑战分析

让我逐个分析技术难点：

**截屏性能问题：**
- 50ms间隔意味着每秒20次截屏
- 需要考虑内存分配、图像格式转换
- 多显示器支持

**人脸检测集成：**
- 需要选择高性能的人脸检测库
- 检测结果需要实时传递给UI
- 检测精度和速度的平衡

**Overlay窗口技术：**
- 透明窗口创建
- 置顶显示
- 事件穿透（让底层窗口接收鼠标键盘事件）
- 马赛克渲染

### 4. 具体技术方案设计

让我设计一个详细的技术方案：

**A. 截屏模块（Rust端）：**
```rust
// 使用Windows API进行高性能截屏
// 考虑使用DirectX或GDI+进行硬件加速
// 图像格式选择：BGRA32位，减少格式转换开销
```

**B. 人脸检测模块：**
```rust
// 集成高性能人脸检测库
// 选项1：OpenCV + DNN
// 选项2：MediaPipe
// 选项3：自研轻量级检测器
```

**C. Overlay窗口管理：**
```rust
// 使用Windows API创建特殊窗口
// 设置WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST
// 实现事件穿透
```

**D. 马赛克渲染：**
```rust
// 在Overlay窗口上绘制马赛克
// 使用Direct2D进行硬件加速渲染
// 马赛克算法：像素化或模糊化
```

### 5. 性能优化策略

**内存管理：**
- 复用图像缓冲区
- 避免频繁的内存分配
- 使用内存池

**多线程架构：**
- 截屏线程：专门负责截屏
- 检测线程：专门负责人脸检测
- UI线程：负责Overlay渲染
- 主线程：协调各个模块

**图像处理优化：**
- 降低检测分辨率（比如1/4大小）
- 使用GPU加速（如果可能）
- 智能区域检测（只检测变化区域）

### 6. 具体实现步骤

让我规划一下实现步骤：

**第一阶段：基础截屏功能**
1. 实现Windows API截屏
2. 测试不同截屏方法的性能
3. 实现多显示器支持

**第二阶段：Overlay窗口**
1. 创建透明置顶窗口
2. 实现事件穿透
3. 基础马赛克渲染

**第三阶段：人脸检测集成**
1. 选择并集成人脸检测库
2. 优化检测性能
3. 实现检测结果传递

**第四阶段：性能优化**
1. 多线程架构
2. 内存优化
3. 延迟优化

### 7. 技术选型建议

**人脸检测库选择：**
- MediaPipe：Google开源，性能优秀
- OpenCV DNN：成熟稳定
- 自研：针对特定场景优化

**图像处理库：**
- Direct2D：Windows原生，性能最佳
- Skia：跨平台，但Windows性能稍差

**并发处理：**
- Tokio：Rust异步运行时
- Rayon：并行计算库

### 8. 潜在问题和解决方案

**问题1：截屏延迟**
- 解决方案：使用DirectX截屏，减少CPU占用

**问题2：人脸检测速度**
- 解决方案：降低检测分辨率，使用GPU加速

**问题3：Overlay窗口闪烁**
- 解决方案：双缓冲渲染，垂直同步

**问题4：内存占用过高**
- 解决方案：图像压缩，内存池管理

### 9. 开发优先级

让我按优先级排序：

1. **高优先级（核心功能）：**
   - Windows API截屏实现
   - Overlay窗口创建
   - 基础马赛克渲染

2. **中优先级（性能优化）：**
   - 人脸检测集成
   - 多线程架构
   - 内存优化

3. **低优先级（用户体验）：**
   - UI界面优化
   - 配置选项
   - 错误处理

### 10. 技术风险评估

**高风险：**
- Overlay窗口的兼容性问题
- 人脸检测的准确性
- 性能达到30fps的挑战

**中风险：**
- 多显示器支持
- 不同Windows版本的兼容性

**低风险：**
- UI界面开发
- 配置管理

## 最终技术方案总结

基于以上分析，我建议采用以下技术方案：

**核心架构：**
- Rust后端：负责截屏、人脸检测、Overlay窗口管理
- React前端：负责用户界面和配置
- Tauri：提供前后端通信

**关键技术选择：**
- 截屏：Windows GDI+ API + DirectX（性能优化）
- 人脸检测：MediaPipe（平衡性能和准确性）
- 渲染：Direct2D（硬件加速）
- 并发：Tokio + Rayon（异步处理）

**性能目标：**
- 截屏延迟：< 16ms（60fps）
- 人脸检测：< 50ms
- 整体延迟：< 100ms

这个方案在技术上可行，但需要大量的性能调优和测试。建议先实现基础功能，再逐步优化性能。

基于React+Tauri+Rust+Windows API的技术栈，我设计了以下技术方案：

**核心架构：**
- Rust后端：截屏、人脸检测、Overlay窗口管理
- React前端：用户界面和配置
- Tauri：前后端通信桥梁

**关键技术选择：**
1. **截屏模块**：Windows GDI+ API + DirectX硬件加速
2. **人脸检测**：MediaPipe（性能与准确性平衡）
3. **Overlay窗口**：Windows API创建透明置顶窗口，实现事件穿透
4. **渲染引擎**：Direct2D硬件加速马赛克渲染
5. **并发处理**：Tokio异步运行时 + Rayon并行计算

**性能优化策略：**
- 多线程架构：截屏线程、检测线程、渲染线程分离
- 内存管理：图像缓冲区复用，避免频繁分配
- 智能检测：降低检测分辨率，只检测变化区域
- 硬件加速：充分利用GPU进行图像处理和渲染

**实现优先级：**
1. 基础截屏功能（Windows API）
2. Overlay窗口创建和事件穿透
3. 人脸检测集成
4. 性能优化和多线程架构

**技术风险：**
- 高：Overlay兼容性、人脸检测准确性、30fps性能要求
- 中：多显示器支持、Windows版本兼容性
- 低：UI开发、配置管理

这个方案技术上可行，但需要大量性能调优。建议先实现MVP，再逐步优化到目标性能。